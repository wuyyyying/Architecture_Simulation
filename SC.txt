-- Name: Sho Ko
-- Username: sko49
-- GTID: 903197992

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;
USE IEEE.STD_LOGIC_MISC.ALL;

-- this implementation supports add, lw, and beq.
ENTITY MIPS IS

PORT(
 signal creset, clock 	: in 	STD_LOGIC;
 signal error 		:out std_logic_vector (3 downto 0));
END 	MIPS; -- the error code is set for unexpected events

ARCHITECTURE behavior OF MIPS IS

-- instruction memory is quite small - load programs by editing the initial values
TYPE INST_MEM IS ARRAY (0 to 15) of STD_LOGIC_VECTOR (31 DOWNTO 0);

SIGNAL iram : INST_MEM := (
x"08000002", --      j 0x2 // need to jump over the next instr
x"00080020", --      add $0, $0, $8 // if execute, program will fail
x"8c040009", --      lw $4, 0x9($0)  // register 4 should have the value 0x02010101
x"8c05000d", --      lw $5, 0xd($0) // register 5 should include the value 0x03020202
x"34a50004", --      ori $5, $5, 0x4 // register 5 should have the value of 0x03020206
x"00a42822", --      sub $5, $5, $4 // register 5 should have the value of 0x01010105
x"34080004", --      ori $8, $0, 0x4 // register 8 should have the value of 0x4
x"00003025", --      or $6, $0, $0 // register 6 should have value 0x0
x"00a62824", --      and $5 $5 $6 // register 5 should have the value of 0x0
x"aca50000", --      sw $5, 0x0($5) // store value of 0x0 to dram of 0x0 to 0x3
x"00C4382a", --      slt $7, $6, $4 // register 7 should have the value of 1
x"00E03820", --      add $7, $7, $0 // register 7 should remain the same
x"00A82820", -- L1:  add $5, $5, $8 // add 0x4 to register 5
x"aca00000", --      sw $0, 0x0($5) // store value of 0x0 to dram 
x"00C73020", --      add $6, $6, $7 // add one to register 6
x"10E6FFFC"  --      beq $7 $6, L1 // branch back to L1 when register 7 and 6 are equal 
);

-- data memory is organized in byte addressable form and some are initialized
TYPE DATA_RAM IS ARRAY (0 to 31) OF STD_LOGIC_VECTOR (7 DOWNTO 0);
   SIGNAL ram: DATA_RAM := (
      X"55", X"55", X"55", X"55",
      X"AA", X"AA", X"AA", X"AA",
      X"01", X"01", X"01", X"01",
      X"02", X"02", X"02", X"02",
      X"03", X"03", X"03", X"03",
      X"00", X"00", X"00", X"00",
      X"00", X"00", X"00", X"00",
      X"00", X"00", X"00", X"00"
      );

-- signals used in fetch logic
signal PC, Next_PC, Branch_PC, JJal_PC, Jr_PC : std_logic_vector(11 downto 0); -- possible PC values
signal Instruction  : std_logic_vector (31 downto 0);
signal RegWrite: std_logic; -- controls when a register is written

-- signals used to read write the register file
TYPE register_file IS ARRAY ( 0 TO 31 ) OF STD_LOGIC_VECTOR( 31 DOWNTO 0 );
SIGNAL register_array	: register_file;

-- intermediate decoded signals
SIGNAL read_data_1, read_data_2, Sign_extend : STD_LOGIC_VECTOR( 31 DOWNTO 0 );
SIGNAL read_register_1_address		: STD_LOGIC_VECTOR( 4 DOWNTO 0 ); -- rs
SIGNAL read_register_2_address		: STD_LOGIC_VECTOR( 4 DOWNTO 0 ); -- rt
SIGNAL write_register_address_1		: STD_LOGIC_VECTOR( 4 DOWNTO 0 ); -- rd
SIGNAL write_register_address_0		: STD_LOGIC_VECTOR( 4 DOWNTO 0 ); -- rt
SIGNAL Instruction_immediate_value	: STD_LOGIC_VECTOR( 15 DOWNTO 0 );
SIGNAL return_address                   : STD_LOGIC_VECTOR( 4 DOWNTO 0); -- signal that represents $31

-- fields of the encoded instruction
signal Function_opcode 	: STD_LOGIC_VECTOR( 5 DOWNTO 0 );
signal Opcode	: std_logic_vector(5 downto 0);

-- control signal to pick the next instruction
signal PC_Mux : std_logic_vector(1 DOWNTO 0); -- extend PC_Mux to 2 bits, support more instructions

BEGIN

  -- the process covers the sequential portion of the fetch logic
	PROCESS
variable Local_PC : std_logic_vector(11 downto 0); -- local computed value of the PC assigned to the PC signal

	BEGIN
	WAIT UNTIL ( clock'EVENT ) AND ( clock = '1' );
		IF creset = '1' THEN
			    Local_PC := X"000" ; -- initialize PC on reset
		ELSE
		case PC_Mux is   -- this is the PC mux logic. Needs to change to support other instructions (e.g., jal)
			when "00" =>
				Local_PC := Next_PC;
			when "01" =>
				Local_PC := Branch_PC;
			when "10" =>
				Local_PC := JJal_PC; -- j and jal
			when "11" =>
				Local_PC := Jr_PC; -- jr
			when others =>
				Local_PC := x"fff"; -- value will indidcate an error in PCMux value
		end case;

		END IF;
			-- update the PC and fetch the next instruction
		PC <= Local_PC; -- remember every signal should have only one driver!
		Instruction <= iram(CONV_INTEGER(Local_PC(5 downto 2)));
                END PROCESS;

	Next_PC <= PC + 4; -- Auto update PC to PC+4. Branches offset from here.


-- extract the fields of the instructions. Note these elements are computed regardless of the specific instruction
	Opcode                       	<= Instruction(31 downto 26);
	Function_opcode              	<= Instruction(5 downto 0);
	read_register_1_address 	<= Instruction( 25 DOWNTO 21 ); -- rs
	read_register_2_address 	<= Instruction( 20 DOWNTO 16 ); -- rt
	write_register_address_1	<= Instruction( 15 DOWNTO 11 ); -- rd
	write_register_address_0 	<= Instruction( 20 DOWNTO 16 ); -- rt which is the destination for some instructions
	Instruction_immediate_value  	<= Instruction( 15 DOWNTO 0 );
	return_address			<= "11111"; -- represent $31
	read_data_1 <= register_array(CONV_INTEGER( read_register_1_address ) );  -- read content of rs

	read_data_2 <= register_array(CONV_INTEGER( read_register_2_address ) );  -- read contents of rt

	Sign_extend <= X"0000" & Instruction_immediate_value  -- Sign Extend 16-bits to 32-bits
                       WHEN Instruction_immediate_value(15) = '0'
                       ELSE	X"FFFF" & Instruction_immediate_value;

-- compute possible next PC values
	Branch_PC 	<= Next_PC + (Sign_extend (9 downto 0) & "00"); -- convert word offset to byte offset
	JJal_PC         <= Instruction (9 DOWNTO 0) & "00"; -- use last 10 bits of j and jal and time 4 to be the absolute address of jump
	Jr_PC           <= read_Data_1 (11 DOWNTO 0); -- read the absolute address in the register and extract the last 12 bits

-- Next instruction address mux. Compute the value of PCMux
PC_Mux <= "01" when ((read_data_1 = read_data_2) and (opcode = "000100")) -- for beq
     else "10" when ((opcode = "000011") or (opcode = "000010")) -- for j and jal
     else "11" when ((opcode = "000000") and (Function_opcode = "001000")) -- for jr
     else "00";  -- for PC + 4

 -- register file write control. Compute the value of the RegWrite signal
RegWrite <= '0' when (opcode = "000100") -- no register writes for beq
      else  '0' when (opcode = "000010") -- no register writes for j
      else  '0' when ((opcode = "000000") and (Function_opcode = "001000")) -- no register writes for jr
      else  '0' when (opcode = "101011") -- no register writes for sw
      else  '1';	-- all other instructions write the register file

PROCESS ( Instruction ) -- when we fetch a new instruction, this process executes
-- declarations for variables whose values are computed in the process,
-- and assigned to signals at the end - remember should have a singe driver
-- for each signal

variable rf_write_data, memory_address  : std_logic_vector(31 downto 0);
variable rf_dest : std_logic_vector (4 downto 0);
variable error_check : std_logic_vector(3 downto 0);
variable branch_condition : std_logic;

    BEGIN
    -- switch on opcode
      CASE Opcode IS
        WHEN "000000" 	=> -- r type
		-- for register-to-register ops need to decode the func field
             CASE Function_opcode IS
              	WHEN "100000" => -- add
                	rf_write_data := read_Data_1 + read_data_2; -- compute the register write value
			rf_dest := write_register_address_1; -- set register destination to rd

		WHEN "100010" => -- sub
			rf_write_data := read_Data_1 - read_data_2; -- rs - rt
			rf_dest := write_register_address_1; -- write to rd

		WHEN "100100" => -- and
			rf_write_data := read_Data_1 and read_data_2; -- rs and rt
			rf_dest := write_register_address_1; -- write to rd

		WHEN "100101" => -- or
			rf_write_data := read_Data_1 or read_data_2;  -- rs or rt
			rf_dest := write_register_address_1; -- write to rd

		WHEN "101010" => -- slt
			if read_Data_1 < read_data_2 then -- if rs < rt
				rf_write_data := x"00000001"; -- rd = 1
			else
				rf_write_data := x"00000000"; -- if rs >= rt, rd = 0
			end if;
			rf_dest := write_register_address_1; -- write to rd

              	WHEN OTHERS =>     -- think of this as an error code denoting illegal func field
             		error_check := x"A";

		END CASE;
	WHEN "100011" => -- lw
             	memory_address := read_data_1 + Sign_extend;
				-- make sure we stay within the 32 byte memory size
             	rf_write_data (7 DOWNTO 0)   := ram(CONV_INTEGER(memory_address (4 downto 0)));
             	rf_write_data (15 DOWNTO 8)  := ram(CONV_INTEGER(memory_address(4 downto 0)+1));
             	rf_write_data (23 DOWNTO 16) := ram(CONV_INTEGER(memory_address(4 downto 0)+2));
             	rf_write_data (31 DOWNTO 24) := ram(CONV_INTEGER(memory_address(4 downto 0)+3));
		rf_dest := write_register_address_0; -- write to rt

	WHEN "101011" => -- sw
		memory_address := read_data_1 + Sign_extend; -- calculate memory address
		ram(CONV_INTEGER(memory_address (4 downto 0)))  <= read_Data_2 (7 DOWNTO 0); -- store byte
		ram(CONV_INTEGER(memory_address(4 downto 0)+1)) <= read_Data_2 (15 DOWNTO 8); -- store byte
		ram(CONV_INTEGER(memory_address(4 downto 0)+2)) <= read_Data_2 (23 DOWNTO 16); -- store byte
		ram(CONV_INTEGER(memory_address(4 downto 0)+3)) <= read_Data_2 (31 DOWNTO 24); -- store byte

	WHEN "001111" => -- lui
		rf_write_data (31 DOWNTO 16) := Instruction_immediate_value; -- upper 16 bits is immediate
		rf_dest := write_register_address_0; -- write to rt

	WHEN "001100" => -- andi;
		rf_write_data := read_Data_1 and (x"0000" & Instruction_immediate_value); -- rs and immediate
		rf_dest := write_register_address_0; -- write to rt

	WHEN "001101" => -- ori
		rf_write_data := read_Data_1 or (x"0000" & Instruction_immediate_value); -- rs or immediate
		rf_dest := write_register_address_0; -- write to rt

	WHEN "001000" => -- addi
		rf_write_data := read_Data_1 + Sign_extend; -- rs + immediate
		rf_dest := write_register_address_0; -- write to rt

	WHEN "000011" => -- jal
		rf_write_data := x"00000" & Next_PC; -- pad zero to Next_PC
		rf_dest := return_address; -- update $31 with Next_PC

	WHEN OTHERS =>
		error_check := x"B";  -- indicates illegal opcode

	END CASE;
	-- write the results of the execution to the register file
		if creset = '1' then
		FOR i IN 0 TO 31 LOOP -- initialize registers on reset
				 register_array(i) <= CONV_STD_LOGIC_VECTOR( i, 32 );
 			 END LOOP;-- update PC adn register file on reset
		else
			if RegWrite = '1' then			-- register file write
				register_array( CONV_INTEGER( rf_dest)) <= rf_write_data;
			end if;
		end if;

		Error <= error_check;

   END PROCESS;
end behavior;